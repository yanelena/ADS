Мы рассмотрели два вида связанных списков: одно- и двухсторонние, когда каждый элемент хранит ссылки либо только на следующий, либо и на следующий, и на предыдущий элементы. Конкретный тип мы можем выбирать в зависимости от задачи. Например, если мы уверены, что данные требуется сканировать только в одном направлении (потоковые структуры, последовательные связанные логи и т. п.), лучше брать односторонний список, как немного более эффективный.

Существует довольно большой класс задач, когда нам очень удобно хранить данные в списке в упорядоченном виде. Во-первых, существенно ускоряется поиск нужного элемента. Во-вторых, данные из "внешнего" хранилища, коим обычно служит такой список, очень здорово сразу брать в отсортированном виде, потому что операция сортировки обычно весьма нагрузочная, особенно если данных хранится много.

Мы воспользуемся общей схемой двустороннего списка, который вы делали во втором задании. Назовём новый тип OrderedList.
Однако теперь нам понадобятся далеко не все методы, которые были в классе LinkedList2. Ведь отныне позиция каждого элемента в списке определяется автоматически, по его значению относительно других элементов.

По сути, нам требуются всего три операции: добавление элемента по его значению, удаление элемента по его значению (остаётся без изменений, как в классе LinkedList2) и нахождение элемента по его значению. И конечно, будет полезен метод преобразования внутреннего списка в стандартный формат данных (например, массив).

Упорядоченный список на практике часто расширяют возможностью обращения к его элементам по индексу (точнее, возможностью получить и сам элемент, если он имеется, и его индекс в списке). Подобный доступ работает не так быстро, как в случае массива (не за O(1)), но и не за O(N), а логарифмически, потому что элементы отсортированы, и можно применять, например, двоичный поиск. Основные операции над таким "упорядоченным массивом" становятся логарифмическими (и доступ, и поиск, и добавление/удаление), и для немалого числа задач такой подход вполне оправдан. Например, мы можем за O(1) получить минимальное, максимальное и среднее значения, за O(N) выявить все дубликаты и найти наиболее часто встречающееся значение, организовать эффективное слияние таких списков, что мы изучаем на курсе по сортировкам и поиску, и т. д.

Задание

Реализуйте:
1. Дополнительную опцию в конструкторе OrderedList, которая указывает, по возрастанию или по убыванию должны храниться элементы в массиве.

2. Метод сравнения двух значений. В общем случае, мы можем хранить в нашем списке произвольные объекты (например, экземпляры класса Cat), и способ, которым мы желаем их сравнивать, потенциально может быть самым произвольным. Пока сделайте базовый вариант этого метода, который сравнивает числовые значения.

3. Добавление нового элемента по значению. Элемент должен вставиться автоматически между двумя подходящими значениями (либо в начало или конец списка) с учётом его значения и признака упорядоченности. Используйте для этого метод сравнения значений из предыдущего пункта.

4. Вариантов реализации упорядоченных списков для разных типов много, например можно создать наследник исходного класса, который в методе сравнения будет сравнивать не числа, а строки.
Но правильнее использовать классы-генерики, если язык это допускает: делать шаблон класса под произвольные типы данных. Недостаток такого подхода в том, что потенциально не все типы допускают сравнение, в некоторых языках например для этого надо дополнительно поддерживать интерфейсы Comparable, и т. д.

Мы в учебной задаче сделаем ограниченную реализацию: создадим единый класс-генерик, а в его методе Compare() будем явно проверять, какой конкретно генерик-тип задан. Если это числа, их можно сравнить арифметически, если это строки, то их надо перед стандартным в любом языке лексикографическом сравнением очистить от начальных и конечных пробелов.

5. Переделайте функцию поиска с учётом признака упорядоченности и возможности раннего прерывания поиска, если найден заведомо больший или меньший элемент, нежели искомый (то есть значение по сути не найдено). Оцените сложность операции поиска, изменилась ли она?

6. Добавьте тесты для добавления, удаления и поиска элемента по его значению -- каждый случай с учётом признака упорядоченности.